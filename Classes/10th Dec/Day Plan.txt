Basics


Given an year - check if it is LEAP
divisible by 4 and not divisible by 100
divisible by 4, 100 as well as 400
                 

Given a number 'n' - split 'n' into parts such that the sum of parts equals 'n' and the product of the parts is the maximum

10 <= n <= 10^7

10
5 5
2 8
3 7
1 1 1 1 1 1 1 1 1 1 
2 2 2 2 2 
1 3 3 3 
2 2 3 3	=> 36
10	1 3 3 3 
10      2 2 3 3 

10	2 2 3 3

11    	2 3 3 3 

12	3 3 3 3 

13	2 2 3 3 3 

14	2 3 3 3 3 
        2 3 3 3 3 

15	3 3 3 3 3 

16	2 2 3 3 3 3



if n % 3 == 1
       4 * pow ( 3, (n-4)/3)
else if n % 3 == 2
       2 * pow ( 3, (n-2)/3)
else
       pow ( 3, (n)/3)












Given 'n' find the sum of all numbers that are divisible by 3 or 5 in the range 1 to 'n'

10 <= n <= 10^9












Algorithms

(The first line represents 'a', the second line represents t

You are required to implement the following function: int LastDigitAPowerB(int a, int b);

The function accepts 2 integers 'a' and 'b' as its arguments. You are required to calculate the last digit of ab, for bigger values of 'a' and 'b', and return the same.
Note:
 a, b 10^7
461258^34798349? hgdfghskjghsdfghdfkjghdfkjghdfkgsfh?
a⁰= 1, where 'a'>0
Example: Input:
a: 6 
b: 14
Output:
6
14.
Explanation:
Since 6¹⁴ is 78364164096 and the last digit of 79364164096 is 6, hince 6 is returned.
The custom input format for the above case:
Sample Input
a:14
b: 10
Sample Output
6
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log2(10000000) = 23.253496664212
log2(1000000)  = 19.931568569324
log2(100000)   = 16.609640474437
log2(10000)    = 13.287712379549
log2(1000)     =  9.9657842846621
log2(100)      =  6.6438561897747
log2(10)       =  3.3219280948874
log2(1)        =  0
Problem Statement: Nth character in Decrypted String
Every character in the input string is followed by its frequency. Write a function to decrypt the string and find the nº character of the decrypted
character exists at that position then return "-1". For eg:- if the input string is "a2b3" the decrypted string is "aabbb".
Note: The frequency of encrypted string cannot be greater than a single digit Le
Input Specification:
input1: a string
input2: n, the position of the character starting from 1
Output Specification:
Return the character which occurs at the n position in the decrypted string Return"-" if no character exists at that position.
Example 1
input1: a1b1c3 
        abccc
        12345
input2: 5
Output: c
a5n7b10r5
23
aaaaannnnnnnbbbbbbbbbbrrrrr
12345678901234567890123









a f  w
8 17 29

a8f9w12f4n8m3
aaaaaaaafffffffffwwwwwwwwwwwwfffnnnnnnnnmmm
0123456789012345678901234567890123456789012

k 27

          0
16 * 1 = 16
16 * 2 = 32
16 * 3 = 48
16 * 4 = 64
16 * 5 = 80
16 * 6 = 96
16 * 7 = 112
16 * 8 = 128
16 * 9 = 144
16 * 10 = 160
16 * 11 = 176
16 * 12 = 192

16
ctr = 0, 1
ctr = ctr + 1
prod = 16 * ctr
print the line
loop




8 | 6974
   -----
8 | 871     6			6               6*1 + 0
  -----	
8 | 108     7			76		7*10 + 6
   ----
8 | 13      4			476		4*100+76
  ----
8 |  1      5			5476		5*1000+476
   ---
8    0      1			15476		1*10000+5476
15476
get quotient
get renmainder
use reaninder and form octal
'increase power
'loop

















a5h6j9k4n5v7x9z1b8m2d9g4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.
Example 1:
Input: s = "owoztneoer"
Output: "012"
Example 2:
Input: s = "fviefuro"
Output: "45"
Constraints:
1 <= s.length <= 10^5
s[i] is one of the characters ["e","g","f","i","h","o","n","s","r","u","t","w","v","x","z"].
s is guaranteed to be valid.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Anagram / Pangram
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Linked List Discusssion

Given an number n, the task is to be broken in such a way that multiplication of its parts is maximized.

Input : n = 10
Output : 36
exp:
10 = 4 + 3 + 3 and 4 * 3 * 3 = 36
is maximum possible product.

Input : n = 8
Output : 18
8 = 2 + 3 + 3 and 2 * 3 * 3 = 18
is maximum possible product.
10 <= n <= 100000
